// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const bBoxForTrack = `-- name: BBoxForTrack :one
SELECT MIN(lon) AS min_lon, MAX(lon) AS max_lon, MIN(lat) AS min_lat, MAX(lat) AS max_lat
FROM positions
WHERE track_id = ?
`

type BBoxForTrackRow struct {
	MinLon interface{}
	MaxLon interface{}
	MinLat interface{}
	MaxLat interface{}
}

func (q *Queries) BBoxForTrack(ctx context.Context, trackID int64) (BBoxForTrackRow, error) {
	row := q.db.QueryRowContext(ctx, bBoxForTrack, trackID)
	var i BBoxForTrackRow
	err := row.Scan(
		&i.MinLon,
		&i.MaxLon,
		&i.MinLat,
		&i.MaxLat,
	)
	return i, err
}

const createTrack = `-- name: CreateTrack :one
INSERT INTO tracks (name, started_at) VALUES (?, ?)
RETURNING id, name, started_at, ended_at, distance_m, notes
`

type CreateTrackParams struct {
	Name      string
	StartedAt int64
}

func (q *Queries) CreateTrack(ctx context.Context, arg CreateTrackParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, createTrack, arg.Name, arg.StartedAt)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartedAt,
		&i.EndedAt,
		&i.DistanceM,
		&i.Notes,
	)
	return i, err
}

const endTrack = `-- name: EndTrack :exec
UPDATE tracks SET ended_at = ? WHERE id = ?
`

type EndTrackParams struct {
	EndedAt sql.NullInt64
	ID      int64
}

func (q *Queries) EndTrack(ctx context.Context, arg EndTrackParams) error {
	_, err := q.db.ExecContext(ctx, endTrack, arg.EndedAt, arg.ID)
	return err
}

const insertPosition = `-- name: InsertPosition :exec
INSERT INTO positions (track_id, t, lon, lat, sog_ms, cog_rad, src, qual)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertPositionParams struct {
	TrackID int64
	T       int64
	Lon     float64
	Lat     float64
	SogMs   sql.NullFloat64
	CogRad  sql.NullFloat64
	Src     sql.NullString
	Qual    sql.NullInt64
}

func (q *Queries) InsertPosition(ctx context.Context, arg InsertPositionParams) error {
	_, err := q.db.ExecContext(ctx, insertPosition,
		arg.TrackID,
		arg.T,
		arg.Lon,
		arg.Lat,
		arg.SogMs,
		arg.CogRad,
		arg.Src,
		arg.Qual,
	)
	return err
}

const insertPositionReturning = `-- name: InsertPositionReturning :one
INSERT INTO positions (track_id, t, lon, lat, sog_ms, cog_rad, src, qual)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id
`

type InsertPositionReturningParams struct {
	TrackID int64
	T       int64
	Lon     float64
	Lat     float64
	SogMs   sql.NullFloat64
	CogRad  sql.NullFloat64
	Src     sql.NullString
	Qual    sql.NullInt64
}

func (q *Queries) InsertPositionReturning(ctx context.Context, arg InsertPositionReturningParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertPositionReturning,
		arg.TrackID,
		arg.T,
		arg.Lon,
		arg.Lat,
		arg.SogMs,
		arg.CogRad,
		arg.Src,
		arg.Qual,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listTracks = `-- name: ListTracks :many
SELECT id, name, started_at, ended_at, distance_m, notes
FROM tracks
ORDER BY started_at DESC
LIMIT ?
`

func (q *Queries) ListTracks(ctx context.Context, limit int64) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listTracks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StartedAt,
			&i.EndedAt,
			&i.DistanceM,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRTree = `-- name: UpsertRTree :exec
INSERT OR REPLACE INTO positions_rtree (id, minX, maxX, minY, maxY)
VALUES (?, ?, ?, ?, ?)
`

type UpsertRTreeParams struct {
	ID   int64
	Minx float64
	Maxx float64
	Miny float64
	Maxy float64
}

func (q *Queries) UpsertRTree(ctx context.Context, arg UpsertRTreeParams) error {
	_, err := q.db.ExecContext(ctx, upsertRTree,
		arg.ID,
		arg.Minx,
		arg.Maxx,
		arg.Miny,
		arg.Maxy,
	)
	return err
}
